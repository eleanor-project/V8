name: Constitutional Governance CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  security-events: write  # For security scanning

jobs:
  # ========================================================================
  # CONSTITUTIONAL GOVERNANCE CHECKS (Blocking)
  # ========================================================================
  governance-invariants:
    name: Constitutional Governance Invariants
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install ".[dev]"

      - name: Test Constitutional Guarantees
        run: |
          python -m pytest tests/test_constitutional_guarantees.py -v
          
      - name: Governance Type Check (Critical Paths)
        run: |
          python -m mypy \
            engine/exceptions.py \
            engine/types.py \
            engine/schemas/escalation.py \
            engine/aggregator/escalation.py \
            engine/execution/human_review.py \
            engine/execution/executor.py \
            governance/critic_escalation.py \
            --strict \
            --warn-return-any \
            --disallow-untyped-defs

      - name: Policy Check - Executor Guardrails
        run: |
          python - <<'PY'
          import ast
          from pathlib import Path
          import sys

          executor_path = Path("engine/execution/executor.py")
          if not executor_path.exists():
              print("Warning: executor.py not yet implemented")
              sys.exit(0)
          
          source = executor_path.read_text()
          tree = ast.parse(source)

          def fail(msg: str) -> None:
              sys.stderr.write(f"❌ GOVERNANCE VIOLATION: {msg}\n")
              sys.exit(1)

          # Verify execute_decision requires ExecutableDecision
          has_ensure_call = False
          for node in tree.body:
              if isinstance(node, ast.FunctionDef) and node.name == "execute_decision":
                  if not node.args.args or node.args.args[0].annotation is None:
                      fail("execute_decision must require ExecutableDecision.")
                  ann = node.args.args[0].annotation
                  if not (isinstance(ann, ast.Name) and ann.id == "ExecutableDecision"):
                      fail("execute_decision must accept ExecutableDecision.")
                  for stmt in node.body:
                      if isinstance(stmt, ast.Expr) and isinstance(stmt.value, ast.Call):
                          func = stmt.value.func
                          if isinstance(func, ast.Name) and func.id == "ensure_executable":
                              has_ensure_call = True
                              break
                  if not has_ensure_call:
                      fail("execute_decision must call ensure_executable before side effects.")
                  break
          else:
              fail("execute_decision not found in executor.")
          
          print("✅ Executor guardrails verified")
          PY

      - name: Policy Check - Human Review Linkage
        run: |
          python - <<'PY'
          import ast
          from pathlib import Path
          import sys

          path = Path("engine/execution/human_review.py")
          if not path.exists():
              print("Warning: human_review.py not yet implemented")
              sys.exit(0)
          
          tree = ast.parse(path.read_text())

          def fail(msg: str) -> None:
              sys.stderr.write(f"❌ GOVERNANCE VIOLATION: {msg}\n")
              sys.exit(1)

          # Ensure _validate_human_action requires aggregation_result
          for node in tree.body:
              if isinstance(node, ast.FunctionDef) and node.name == "_validate_human_action":
                  kw_names = [a.arg for a in node.args.kwonlyargs]
                  if "aggregation_result" not in kw_names:
                      fail("_validate_human_action must accept aggregation_result.")
                  break
          else:
              fail("_validate_human_action not found in human_review.py.")

          # Ensure enforce_human_review passes aggregation_result
          for node in tree.body:
              if isinstance(node, ast.FunctionDef) and node.name == "enforce_human_review":
                  for stmt in ast.walk(node):
                      if isinstance(stmt, ast.Call) and isinstance(stmt.func, ast.Name) and stmt.func.id == "_validate_human_action":
                          kw = {k.arg for k in stmt.keywords}
                          if "aggregation_result" not in kw:
                              fail("enforce_human_review must pass aggregation_result.")
                          break
                  else:
                      fail("No _validate_human_action call in enforce_human_review.")
                  break
          else:
              fail("enforce_human_review not found in human_review.py.")
          
          print("✅ Human review linkage verified")
          PY

      - name: Policy Check - Evidence Recording Failures
        run: |
          python - <<'PY'
          import ast
          from pathlib import Path
          import sys

          # Verify evidence recording failures are not silently caught
          recorder_path = Path("engine/recorder/evidence_recorder.py")
          if not recorder_path.exists():
              recorder_path = Path("engine/audit.py")
          
          if not recorder_path.exists():
              print("Warning: evidence recorder not found")
              sys.exit(0)

          source = recorder_path.read_text()
          
          # Check for bare except clauses that might silence evidence failures
          tree = ast.parse(source)
          bare_excepts = []
          
          for node in ast.walk(tree):
              if isinstance(node, ast.ExceptHandler):
                  if node.type is None:  # Bare except:
                      bare_excepts.append(node.lineno)
          
          if bare_excepts:
              print(f"⚠️  Warning: Bare except clauses at lines {bare_excepts}")
              print("Evidence recording failures should use specific exceptions")
          
          print("✅ Evidence recording policy verified")
          PY

  # ========================================================================
  # SECURITY SCANNING
  # ========================================================================
  security:
    name: Security Scanning
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install ".[dev]"

      - name: Run Bandit Security Scan
        run: |
          python -m bandit -r engine/ api/ governance/ -lll -f json -o bandit-report.json
          python -m bandit -r engine/ api/ governance/ -lll -f screen

      - name: Check Dependency Vulnerabilities
        run: |
          python -m safety check --output json --save-json safety-report.json
          python -m safety check

      - name: Upload Security Reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports
          path: |
            bandit-report.json
            safety-report.json

  # ========================================================================
  # CODE QUALITY
  # ========================================================================
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install ".[dev]"

      - name: Run Ruff Linter
        run: |
          python -m ruff check engine/ api/ governance/ tests/

      - name: Run Ruff Formatter Check
        run: |
          python -m ruff format --check engine/ api/ governance/ tests/

      - name: Type Check with MyPy
        run: |
          python -m mypy engine/ api/ governance/ \
            --ignore-missing-imports \
            --warn-return-any \
            --warn-unused-configs

  # ========================================================================
  # TESTING & COVERAGE
  # ========================================================================
  test:
    name: Test Suite
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install ".[dev]"

      - name: Run Tests with Coverage
        run: |
          python -m pytest \
            --cov=engine \
            --cov=api \
            --cov=governance \
            --cov-report=term-missing \
            --cov-report=xml \
            --cov-report=html \
            --cov-fail-under=80 \
            -v

      - name: Upload Coverage Reports
        uses: actions/upload-artifact@v4
        if: matrix.python-version == '3.11'
        with:
          name: coverage-reports
          path: |
            coverage.xml
            htmlcov/

  # ========================================================================
  # PERFORMANCE REGRESSION
  # ========================================================================
  performance:
    name: Performance Benchmarks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install ".[dev]"

      - name: Run Benchmarks
        run: |
          ELEANOR_RUN_BENCHMARKS=1 python -m pytest tests/performance/ \
            --benchmark-only \
            --benchmark-json=benchmark.json

      - name: Check Performance Regression
        run: |
          python scripts/check_performance_regression.py --input benchmark.json

  # ========================================================================
  # DOCKER VALIDATION
  # ========================================================================
  docker:
    name: Docker Build Validation
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build Docker Images
        run: |
          docker compose -f docker/docker-compose.yaml build
          docker compose -f docker/docker-compose.yaml config --quiet

  # ========================================================================
  # DOCUMENTATION
  # ========================================================================
  docs:
    name: Documentation Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify Constitutional Documentation
        run: |
          required_docs=(
            "docs/CRITIC_INDEPENDENCE_AND_ESCALATION.md"
            "docs/ESCALATION_Tiers_Human_Review_Doctrine.md"
            "README.md"
          )
          
          for doc in "${required_docs[@]}"; do
            if [ ! -f "$doc" ]; then
              echo "❌ Missing required documentation: $doc"
              exit 1
            fi
          done
          
          echo "✅ All required documentation present"

      - name: Check for TODOs in Critical Paths
        run: |
          if grep -r "TODO\|FIXME\|XXX" engine/execution/ engine/governance/ engine/exceptions.py 2>/dev/null; then
            echo "⚠️  Warning: TODOs found in critical governance paths"
          else
            echo "✅ No TODOs in critical paths"
          fi

  # ========================================================================
  # STATUS CHECK
  # ========================================================================
  status:
    name: CI Status
    runs-on: ubuntu-latest
    needs: [governance-invariants, security, quality, test, performance, docker, docs]
    if: always()
    steps:
      - name: Check Status
        run: |
          if [ "${{ needs.governance-invariants.result }}" != "success" ]; then
            echo "❌ Constitutional governance checks failed"
            exit 1
          fi
          
          if [ "${{ needs.test.result }}" != "success" ]; then
            echo "❌ Test suite failed"
            exit 1
          fi

          if [ "${{ needs.performance.result }}" != "success" ]; then
            echo "❌ Performance benchmarks failed"
            exit 1
          fi

          if [ "${{ needs.docker.result }}" != "success" ]; then
            echo "❌ Docker build validation failed"
            exit 1
          fi
          
          if [ "${{ needs.security.result }}" != "success" ]; then
            echo "❌ Security scans failed"
            exit 1
          fi

          if [ "${{ needs.quality.result }}" != "success" ]; then
            echo "❌ Code quality checks failed"
            exit 1
          fi

          if [ "${{ needs.docs.result }}" != "success" ]; then
            echo "❌ Documentation checks failed"
            exit 1
          fi
          
          echo "✅ CI pipeline completed"
